#include "../headers/ai_algorithm.hpp"
#include <algorithm>
#include <typeinfo>
#include <chrono>
#include <string>
#include <vector>

Game::Game(int white_ai, int black_ai)
{
	//there should really be some kind of mapping from ai_id to real ai but for now the id will only be difficulty of the ai in question.
}


int Game::update()
{
	int currTime = (int)clock.getElapsedTime().asSeconds() + timeOffset;
	// Update clockstring
	clockText.setString(std::to_string(currTime / 60) + ":" + std::to_string(currTime % 60));

	// Human turn
	if (playerOnTurn->getType() == std::string("Human")) {
		sf::Event event;
		while (window.pollEvent(event)) {
			sf::Vector2f mousePos = (sf::Vector2f)sf::Mouse::getPosition(window);
			if (event.type == sf::Event::MouseMoved) {
				if (saveButton.containsMousePos(mousePos)) {
					saveButton.setState(Highlighted);
				}
				else if (mainMenuButton.containsMousePos(mousePos)) {
					mainMenuButton.setState(Highlighted);
				}
				else
					clearButtonHighlights(buttons);
			}
			if (event.type == sf::Event::MouseButtonPressed) {

				if (saveButton.containsMousePos(mousePos)) {
					// Get the current time
					timeOffset += (int)clock.getElapsedTime().asSeconds();
					showSaveGameDialog();
					restartClock();
				}
				else if (mainMenuButton.containsMousePos(mousePos)) {
					// Get the current time
					timeOffset += (int)clock.getElapsedTime().asSeconds();
					return 0;
				}
				else {
					for (int i = 0; i < 64; i++) {
						if (gameBoard[i]->containsMousePos(mousePos)) {
							// If no piece active yet
							if (activeSquare == -1) {
								if (containsPlayerPiece(i, playerOnTurn))
								{
									possibleMoves = board.possibleMoves(i);
									highlight(possibleMoves);
									activeSquare = i;
								}
							}
							// If possible moves already found
							else if (activeSquare != -1 && (std::find(possibleMoves.begin(), possibleMoves.end(), i) != possibleMoves.end()) && i != activeSquare) {
								std::pair<int, int> pair = std::make_pair(activeSquare, i);
								movePiece(pair);

								std::cout << playerOnTurn->getName() << " made move." << std::endl;
								activeSquare = -1;
								possibleMoves.clear();
								clearHighlights(gameBoard);
								return changeTurn();
							}
							else {
								activeSquare = -1;
								possibleMoves.clear();
								clearHighlights(gameBoard);
							}
						}
					}
				}
			}
			else if (event.type == sf::Event::Closed) {
			   window.close();
			   return -1;
			}
		}
	}
	// AI Turn
	else if (playerOnTurn->getType() == std::string("AI")) {
	/* Here thread_flag tells if we need a new move. if thread_flag IS active it means <> otherwise <>
	 * thread_erased tells if last thread we launched has finished so even if we need a new move we can't ask for one before that TODO:Why we cant?
	 */
		if (!waitingAiMove && !(board.getState() & 0x3)) { // Make sure that no moves is asked after checkmate or stalemate
			if(thread_erased) // See if last aithread has finished
			{
				// Start new thread and calculate time elapsed for algorithm
				aiClock.restart();
				aithread = std::thread(&GameScreen::getAiMove, this); // The actual calculation starts here
				waitingAiMove = true;
			}
		}

		sf::Event event;

		while (window.pollEvent(event)) {
			sf::Vector2f mousePos = (sf::Vector2f)sf::Mouse::getPosition(window);
			if (event.type == sf::Event::MouseMoved) {
				if (saveButton.containsMousePos(mousePos)) {
					saveButton.setState(Highlighted);
				}
				else if (mainMenuButton.containsMousePos(mousePos)) {
					mainMenuButton.setState(Highlighted);
				}
				else
					clearButtonHighlights(buttons);
			}
			if (event.type == sf::Event::MouseButtonPressed)
			{

				if (saveButton.containsMousePos(mousePos))
				{
					// Get current time
					timeOffset += (int)clock.getElapsedTime().asSeconds();
					showSaveGameDialog();
					clock.restart();
				}
				else if (mainMenuButton.containsMousePos(mousePos)) {
					if(!thread_erased)
					{
						if(waitingAiMove == true)
						{
							waitingAiMove = false; // If user goes to mainmenu while calculating -> abandon calculation
							aithread.detach();
						}
					}
					// Get current time
					timeOffset += (int)clock.getElapsedTime().asSeconds();
					return 0;
				}
			}
		}

		if(aimove.first != aimove.second && waitingAiMove == true) // Means that getaimove thread is ALMOST ready
		{
			// TODO: Comment this block
			aithread.join();
			std::pair<int, int> temp;
			ai_algorithm_mutex.lock();
			{
				temp.first = aimove.first;
				temp.second = aimove.second;
			}
			ai_algorithm_mutex.unlock();

			movePiece(temp);
			
			std::cout << "AI(lvl:" << playerOnTurn->getLevel() << ") calculated next turn in " << aiClock.getElapsedTime().asSeconds() << " seconds." << std::endl;
			ai_algorithm_mutex.lock();
			{
				aimove.first = 0;
				aimove.second = 0;
			}
			ai_algorithm_mutex.unlock();

			waitingAiMove = false;
			return changeTurn();
		}
	}
	return 2;
}

